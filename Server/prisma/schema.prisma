generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                Int                 @id @default(autoincrement())
  email             String              @unique
  userName          String              @unique
  phoneNo           Int?
  address           String?
  smartAddress      String              @unique
  profileImageUrl   String?
  createdChamas     Chama[]             @relation("AdminChamas")
  chamas            ChamaMember[]
  joinRequests      ChamaRequest[]
  notifications     Notification[]
  payments          Payment[]
  messages          Message[]
  payOuts           PayOut[]
  mpesaTransactions MpesaTransaction[]
}

model Chama {
  id            Int              @id @default(autoincrement())
  name          String
  slug          String           @unique
  description   String?
  adminTerms    String?
  type          String
  startDate     DateTime
  payDate       DateTime
  cycleTime     Int
  started       Boolean          @default(false)
  amount        String
  round         Int              @default(1)
  cycle         Int              @default(1)
  maxNo         Int              @default(15)
  rating        Int              @default(0)
  raterCount    Int              @default(0)
  blockchainId  String
  adminId       Int
  canJoin       Boolean          @default(true)
  payOutOrder   String?
  createdAt     DateTime         @default(now())
  admin         User             @relation("AdminChamas", fields: [adminId], references: [id])
  members       ChamaMember[]
  requests      ChamaRequest[]
  notifications Notification[]
  payments      Payment[]
  messages      Message[]
  payOuts       PayOut[]
  roundOutcome  roundOutcome[]
}

model ChamaMember {
  id      Int      @id @default(autoincrement())
  userId  Int
  chamaId Int
  chama   Chama    @relation(fields: [chamaId], references: [id])
  user    User     @relation(fields: [userId], references: [id])
  payDate DateTime
}

model Payment {
  id          Int      @id @default(autoincrement())
  amount      String
  description String?
  doneAt      DateTime @default(now())
  txHash      String
  userId      Int
  chamaId     Int
  chama       Chama    @relation(fields: [chamaId], references: [id])
  user        User     @relation(fields: [userId], references: [id])
}

model Notification {
  id        Int      @id @default(autoincrement())
  message   String
  senderId  Int?
  requestId Int?
  userId    Int
  chamaId   Int?
  read      Boolean  @default(false)
  createdAt DateTime @default(now())
  chama     Chama?   @relation(fields: [chamaId], references: [id])
  user      User     @relation(fields: [userId], references: [id])
}

model ChamaRequest {
  id        Int      @id @default(autoincrement())
  status    String   @default("pending")
  createdAt DateTime @default(now())
  userId    Int
  chamaId   Int
  chama     Chama    @relation(fields: [chamaId], references: [id])
  user      User     @relation(fields: [userId], references: [id])
}

model Message {
  id        Int      @id @default(autoincrement())
  chama     Chama    @relation(fields: [chamaId], references: [id])
  chamaId   Int
  sender    User     @relation(fields: [senderId], references: [id])
  senderId  Int
  text      String
  timestamp DateTime @default(now())
}

model PayOut {
  id       Int      @id @default(autoincrement())
  amount   String
  doneAt   DateTime @default(now())
  txHash   String?
  receiver String
  userId   Int
  chamaId  Int
  chama    Chama    @relation(fields: [chamaId], references: [id])
  user     User     @relation(fields: [userId], references: [id])
}

model roundOutcome {
  id           Int      @id @default(autoincrement())
  disburse     Boolean
  chamaCycle   Int
  chamaRound   Int
  amountPaid   String
  shownMembers String?
  createdAt    DateTime @default(now())
  chamaId      Int
  chama        Chama    @relation(fields: [chamaId], references: [id])
}

// Unified M-Pesa Transaction Model (supports both payments and onramp)
model MpesaTransaction {
  id                  Int      @id @default(autoincrement())
  userId              Int
  merchantRequestID   String   @unique
  checkoutRequestID   String   @unique
  phoneNumber         String
  amount              Decimal  @db.Decimal(10, 2)
  type                String   @default("payment") // "payment" or "onramp"
  status              String   @default("pending") // pending, completed, failed, cancelled, timeout
  mpesaReceiptNumber  String?
  transactionDate     String?
  resultCode          Int?
  resultDesc          String?
  accountReference    String?
  transactionDesc     String?
  chamaId             Int?     // For chama payments
  
  // Onramp-specific fields
  cusdAmount          Decimal? @db.Decimal(18, 6)  // cUSD amount for onramp
  exchangeRate        Decimal? @db.Decimal(10, 2)  // Exchange rate used
  walletAddress       String?  // Destination wallet for onramp
  blockchainTxHash    String?  // Blockchain transaction hash
  
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  user                User     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([checkoutRequestID])
  @@index([status])
  @@index([type])
  @@index([createdAt])
}